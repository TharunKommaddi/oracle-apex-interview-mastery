<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Oracle SQL Interview Questions - APEX Interview Mastery</title>
    <meta name="description" content="Master Oracle SQL with comprehensive interview questions from basic to advanced levels.">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <!-- Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Styles -->
    <link rel="stylesheet" href="assets/css/style.css">
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='0.9em' font-size='90'>üóÑÔ∏è</text></svg>">
</head>
<body>
    <header class="header">
        <div class="nav-container">
            <a href="index.html" class="logo">
                <i class="fas fa-code"></i>
                APEX Interview Mastery
            </a>
            <nav>
                <ul class="nav-menu" id="navMenu">
                    <li class="nav-item">
                        <a href="index.html">
                            <i class="fas fa-home"></i> Home
                        </a>
                    </li>
                    <li class="nav-item">
                        <a href="oracle-sql.html" class="active">
                            <i class="fas fa-database"></i> Oracle SQL
                        </a>
                    </li>
                    <li class="nav-item">
                        <a href="plsql.html">
                            <i class="fas fa-code-branch"></i> PL/SQL
                        </a>
                    </li>
                    <li class="nav-item">
                        <a href="oracle-apex.html">
                            <i class="fas fa-layer-group"></i> Oracle APEX
                        </a>
                    </li>
                    <li class="nav-item dropdown">
                        <a href="#" class="dropdown-toggle">
                            <i class="fas fa-paint-brush"></i> Frontend <i class="fas fa-chevron-down"></i>
                        </a>
                        <ul class="dropdown-menu">
                            <li><a href="html-questions.html"><i class="fab fa-html5"></i> HTML</a></li>
                            <li><a href="css-questions.html"><i class="fab fa-css3-alt"></i> CSS</a></li>
                            <li><a href="javascript-questions.html"><i class="fab fa-js"></i> JavaScript</a></li>
                            <li><a href="jquery-questions.html"><i class="fas fa-dollar-sign"></i> jQuery</a></li>
                        </ul>
                    </li>
                </ul>
                <button class="mobile-menu-toggle" onclick="toggleMobileMenu()" aria-label="Toggle mobile menu">
                    <i class="fas fa-bars"></i>
                </button>
            </nav>
        </div>
    </header>

    <section class="page-header">
        <h1 class="page-title">Oracle SQL Interview Questions</h1>
        <p class="page-subtitle">Master Oracle SQL with comprehensive questions from basic to advanced levels</p>
    </section>

    <div class="container">
        <div class="filter-section">
            <div class="filter-title">
                <i class="fas fa-database"></i> Filter Questions
            </div>
            <div class="filter-tabs">
                <button class="filter-tab active" onclick="filterQuestions('all')">All Questions</button>
                <button class="filter-tab" onclick="filterQuestions('basic')">Basic</button>
                <button class="filter-tab" onclick="filterQuestions('intermediate')">Intermediate</button>
                <button class="filter-tab" onclick="filterQuestions('advanced')">Advanced</button>
            </div>
            <div class="search-container">
                <i class="fas fa-search search-icon"></i>
                <input type="text" class="search-input" placeholder="Search SQL questions..." 
                       onkeyup="searchQuestions()" id="searchInput" aria-label="Search questions">
            </div>
        </div>

        <div id="questionsContainer" class="questions-container">
            <!-- Questions will be loaded here by JavaScript -->
        </div>
    </div>

    <footer class="footer">
        <div class="footer-content">
            <h3>Ready to Master Oracle SQL?</h3>
            <p>Practice these essential questions to excel in your Oracle APEX interviews</p>
            <div class="footer-links">
                <a href="index.html">Home</a>
                <a href="oracle-apex.html">APEX Questions</a>
                <a href="plsql.html">PL/SQL Questions</a>
            </div>
        </div>
    </footer>

    <script src="assets/js/script.js"></script>
    <script>
        // Oracle SQL Questions Data (Minimal for testing)

const oracleSqlQuestions = [
    {
        id: 1,
        category: 'basic',
        difficulty: 'basic',
        question: 'How can you find the Nth highest salary from a table in Oracle?',
        answer: 'There are multiple approaches to find the Nth highest salary in Oracle using ranking functions, subqueries, and advanced analytical functions.',
        language: 'Oracle SQL',
        code: `-- Method 1: Using ROW_NUMBER() - Most efficient for unique values
SELECT salary 
FROM (
    SELECT salary, ROW_NUMBER() OVER (ORDER BY salary DESC) as rn
    FROM employee
    WHERE salary IS NOT NULL
)
WHERE rn = :N;

-- Method 2: Using DENSE_RANK() - Handles duplicates better
SELECT DISTINCT salary 
FROM (
    SELECT salary, DENSE_RANK() OVER (ORDER BY salary DESC) as rnk
    FROM employee
    WHERE salary IS NOT NULL
)
WHERE rnk = :N;

-- Method 3: Using RANK() - Standard ranking with gaps
SELECT DISTINCT salary 
FROM (
    SELECT salary, RANK() OVER (ORDER BY salary DESC) as rank_num
    FROM employee
    WHERE salary IS NOT NULL
)
WHERE rank_num = :N;

-- Method 4: Using ROWNUM (Oracle-specific)
SELECT salary
FROM (
    SELECT DISTINCT salary
    FROM employee
    WHERE salary IS NOT NULL
    ORDER BY salary DESC
)
WHERE ROWNUM = :N;

-- Method 5: Using OFFSET and FETCH (Oracle 12c+)
SELECT DISTINCT salary
FROM employee
WHERE salary IS NOT NULL
ORDER BY salary DESC
OFFSET (:N - 1) ROWS FETCH NEXT 1 ROWS ONLY;`
    },
    {
        id: 2,
        category: 'basic',
        difficulty: 'basic',
        question: 'What is the difference between UNION and UNION ALL in Oracle?',
        answer: 'UNION removes duplicates and sorts the result, while UNION ALL preserves all rows including duplicates and is faster.',
        language: 'Oracle SQL',
        code: `-- UNION: Removes duplicates and sorts (slower)
SELECT employee_id, first_name, 'ACTIVE' as status
FROM employees
WHERE hire_date > SYSDATE - 365
UNION
SELECT employee_id, first_name, 'INACTIVE' as status
FROM former_employees
WHERE termination_date > SYSDATE - 365;

-- UNION ALL: Keeps all rows including duplicates (faster)
SELECT employee_id, first_name, 'ACTIVE' as status
FROM employees
WHERE hire_date > SYSDATE - 365
UNION ALL
SELECT employee_id, first_name, 'INACTIVE' as status
FROM former_employees
WHERE termination_date > SYSDATE - 365;

-- Performance comparison with execution plan
SELECT /*+ GATHER_PLAN_STATISTICS */ COUNT(*) as union_count
FROM (
    SELECT department_id FROM employees
    UNION
    SELECT department_id FROM departments
);

SELECT /*+ GATHER_PLAN_STATISTICS */ COUNT(*) as union_all_count
FROM (
    SELECT department_id FROM employees
    UNION ALL
    SELECT department_id FROM departments
);

-- Real-world example: Combining current and historical data
SELECT employee_id, salary, 'CURRENT' as record_type, SYSDATE as query_date
FROM employees
WHERE status = 'ACTIVE'
UNION ALL
SELECT employee_id, salary, 'HISTORICAL' as record_type, archive_date
FROM employee_history
WHERE archive_date > SYSDATE - 90
ORDER BY employee_id, record_type;`
    },
    {
        id: 3,
        category: 'basic',
        difficulty: 'basic',
        question: 'How do you handle NULL values in Oracle SQL?',
        answer: 'Oracle provides several functions to handle NULL values: NVL, NVL2, NULLIF, COALESCE, and IS NULL/IS NOT NULL operators.',
        language: 'Oracle SQL',
        code: `-- NVL: Replace NULL with a default value
SELECT employee_id, 
       first_name, 
       NVL(middle_name, 'No Middle Name') as middle_name,
       NVL(salary, 0) as salary
FROM employees;

-- NVL2: Different values based on NULL/NOT NULL
SELECT employee_id,
       first_name,
       NVL2(commission_pct, 
            salary + (salary * commission_pct), 
            salary) as total_compensation
FROM employees;

-- COALESCE: Returns first non-NULL value
SELECT employee_id,
       COALESCE(work_phone, mobile_phone, home_phone, 'No Phone') as contact_number
FROM employees;

-- NULLIF: Returns NULL if values are equal
SELECT employee_id,
       salary,
       NULLIF(salary, 0) as non_zero_salary
FROM employees;

-- IS NULL and IS NOT NULL operators
SELECT COUNT(*) as employees_with_commission
FROM employees
WHERE commission_pct IS NOT NULL;

SELECT COUNT(*) as employees_without_manager
FROM employees
WHERE manager_id IS NULL;

-- Advanced NULL handling in calculations
SELECT employee_id,
       salary,
       commission_pct,
       -- NULL in arithmetic operations returns NULL
       salary * commission_pct as commission_amount,
       -- Using NVL to handle NULL in calculations
       salary * NVL(commission_pct, 0) as safe_commission_amount,
       -- Using CASE for complex NULL logic
       CASE 
           WHEN commission_pct IS NULL THEN salary
           WHEN commission_pct = 0 THEN salary
           ELSE salary + (salary * commission_pct)
       END as total_compensation
FROM employees;

-- NULL in WHERE clause considerations
SELECT employee_id, first_name, manager_id
FROM employees
WHERE manager_id != 100;  -- This will NOT return rows where manager_id is NULL

-- Correct way to include NULL values
SELECT employee_id, first_name, manager_id
FROM employees
WHERE manager_id != 100 OR manager_id IS NULL;

-- Or using NVL in WHERE clause
SELECT employee_id, first_name, manager_id
FROM employees
WHERE NVL(manager_id, -1) != 100;`
    },
    {
        id: 4,
        category: 'intermediate',
        difficulty: 'intermediate',
        question: 'Write a query to get the monthly sales amount for the last 12 months in Oracle.',
        answer: 'Use Oracle date functions, analytical functions, and GROUP BY to calculate monthly sales with proper date handling and formatting.',
        language: 'Oracle SQL',
        code: `-- Basic monthly sales for last 12 months
SELECT 
    TO_CHAR(sale_date, 'YYYY-MM') AS sales_month,
    TO_CHAR(sale_date, 'Mon YYYY') AS month_name,
    SUM(amount) AS monthly_sales,
    COUNT(*) AS total_transactions,
    ROUND(AVG(amount), 2) AS avg_transaction_amount,
    MIN(amount) AS min_sale,
    MAX(amount) AS max_sale
FROM sales 
WHERE sale_date >= ADD_MONTHS(TRUNC(SYSDATE, 'MM'), -12)
  AND sale_date < TRUNC(SYSDATE, 'MM')
GROUP BY 
    TO_CHAR(sale_date, 'YYYY-MM'), 
    TO_CHAR(sale_date, 'Mon YYYY'),
    EXTRACT(YEAR FROM sale_date),
    EXTRACT(MONTH FROM sale_date)
ORDER BY 
    TO_CHAR(sale_date, 'YYYY-MM') DESC;

-- Advanced version with running totals and comparisons
WITH monthly_sales AS (
    SELECT 
        TRUNC(sale_date, 'MM') AS month_start,
        TO_CHAR(sale_date, 'YYYY-MM') AS sales_month,
        TO_CHAR(sale_date, 'Mon YYYY') AS month_name,
        SUM(amount) AS monthly_sales,
        COUNT(*) AS total_transactions,
        ROUND(AVG(amount), 2) AS avg_transaction_amount
    FROM sales 
    WHERE sale_date >= ADD_MONTHS(TRUNC(SYSDATE, 'MM'), -12)
      AND sale_date < TRUNC(SYSDATE, 'MM')
    GROUP BY 
        TRUNC(sale_date, 'MM'),
        TO_CHAR(sale_date, 'YYYY-MM'), 
        TO_CHAR(sale_date, 'Mon YYYY')
)
SELECT 
    sales_month,
    month_name,
    monthly_sales,
    total_transactions,
    avg_transaction_amount,
    -- Running total
    SUM(monthly_sales) OVER (ORDER BY month_start) AS running_total,
    -- Previous month comparison
    LAG(monthly_sales, 1) OVER (ORDER BY month_start) AS prev_month_sales,
    -- Month over month growth
    ROUND(
        (monthly_sales - LAG(monthly_sales, 1) OVER (ORDER BY month_start)) / 
        NULLIF(LAG(monthly_sales, 1) OVER (ORDER BY month_start), 0) * 100, 2
    ) AS mom_growth_pct,
    -- 3-month moving average
    ROUND(
        AVG(monthly_sales) OVER (
            ORDER BY month_start 
            ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
        ), 2
    ) AS three_month_avg,
    -- Rank by sales amount
    RANK() OVER (ORDER BY monthly_sales DESC) AS sales_rank
FROM monthly_sales
ORDER BY month_start DESC;

-- Version with complete 12-month period (including months with no sales)
WITH month_series AS (
    SELECT 
        ADD_MONTHS(TRUNC(SYSDATE, 'MM'), -LEVEL) AS month_start,
        TO_CHAR(ADD_MONTHS(TRUNC(SYSDATE, 'MM'), -LEVEL), 'YYYY-MM') AS sales_month,
        TO_CHAR(ADD_MONTHS(TRUNC(SYSDATE, 'MM'), -LEVEL), 'Mon YYYY') AS month_name
    FROM dual
    CONNECT BY LEVEL <= 12
),
monthly_sales AS (
    SELECT 
        TRUNC(sale_date, 'MM') AS month_start,
        SUM(amount) AS monthly_sales,
        COUNT(*) AS total_transactions,
        ROUND(AVG(amount), 2) AS avg_transaction_amount
    FROM sales 
    WHERE sale_date >= ADD_MONTHS(TRUNC(SYSDATE, 'MM'), -12)
      AND sale_date < TRUNC(SYSDATE, 'MM')
    GROUP BY TRUNC(sale_date, 'MM')
)
SELECT 
    ms.sales_month,
    ms.month_name,
    NVL(s.monthly_sales, 0) AS monthly_sales,
    NVL(s.total_transactions, 0) AS total_transactions,
    NVL(s.avg_transaction_amount, 0) AS avg_transaction_amount,
    -- Year over year comparison if data exists
    CASE 
        WHEN NVL(s.monthly_sales, 0) > 0 THEN 'Has Sales'
        ELSE 'No Sales'
    END AS sales_status
FROM month_series ms
LEFT JOIN monthly_sales s ON ms.month_start = s.month_start
ORDER BY ms.month_start DESC;`
    },
    {
        id: 5,
        category: 'intermediate',
        difficulty: 'intermediate',
        question: 'What are Oracle analytical functions and how do you use them?',
        answer: 'Oracle analytical functions perform calculations across a set of rows related to the current row, without collapsing the result set. Common functions include ROW_NUMBER(), RANK(), LAG(), LEAD(), etc.',
        language: 'Oracle SQL',
        code: `-- Comprehensive Oracle Analytical Functions Demo
SELECT 
    employee_id,
    first_name,
    last_name,
    department_id,
    salary,
    hire_date,
    
    -- RANKING FUNCTIONS
    ROW_NUMBER() OVER (ORDER BY salary DESC) as row_num,
    RANK() OVER (ORDER BY salary DESC) as salary_rank,
    DENSE_RANK() OVER (ORDER BY salary DESC) as dense_salary_rank,
    
    -- RANKING within partitions
    ROW_NUMBER() OVER (PARTITION BY department_id ORDER BY salary DESC) as dept_row_num,
    RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as dept_salary_rank,
    
    -- PERCENTILE functions
    PERCENT_RANK() OVER (ORDER BY salary) as salary_percentile,
    CUME_DIST() OVER (ORDER BY salary) as salary_cumulative_dist,
    NTILE(4) OVER (ORDER BY salary) as salary_quartile,
    
    -- LAG and LEAD functions
    LAG(salary, 1) OVER (ORDER BY hire_date) as prev_hired_salary,
    LEAD(salary, 1) OVER (ORDER BY hire_date) as next_hired_salary,
    LAG(hire_date, 1) OVER (PARTITION BY department_id ORDER BY hire_date) as prev_dept_hire,
    
    -- FIRST_VALUE and LAST_VALUE
    FIRST_VALUE(salary) OVER (
        PARTITION BY department_id 
        ORDER BY salary DESC 
        ROWS UNBOUNDED PRECEDING
    ) as highest_dept_salary,
    
    LAST_VALUE(salary) OVER (
        PARTITION BY department_id 
        ORDER BY salary DESC 
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) as lowest_dept_salary,
    
    -- NTH_VALUE
    NTH_VALUE(salary, 2) OVER (
        PARTITION BY department_id 
        ORDER BY salary DESC 
        ROWS UNBOUNDED PRECEDING
    ) as second_highest_dept_salary,
    
    -- AGGREGATE functions as analytical functions
    SUM(salary) OVER (PARTITION BY department_id) as total_dept_salary,
    AVG(salary) OVER (PARTITION BY department_id) as avg_dept_salary,
    COUNT(*) OVER (PARTITION BY department_id) as dept_employee_count,
    
    -- Running totals and moving averages
    SUM(salary) OVER (ORDER BY hire_date) as running_salary_total,
    AVG(salary) OVER (
        ORDER BY hire_date 
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) as three_row_moving_avg,
    
    -- RATIO_TO_REPORT
    RATIO_TO_REPORT(salary) OVER (PARTITION BY department_id) as salary_ratio_in_dept,
    
    -- Window frame examples
    SUM(salary) OVER (
        PARTITION BY department_id 
        ORDER BY hire_date 
        ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING
    ) as salary_sum_3_rows,
    
    -- RANGE window frame
    AVG(salary) OVER (
        ORDER BY hire_date 
        RANGE BETWEEN INTERVAL '1' YEAR PRECEDING AND CURRENT ROW
    ) as avg_salary_last_year

FROM employees
ORDER BY department_id, salary DESC;

-- Advanced analytical queries
-- Example 1: Top N employees per department
WITH ranked_employees AS (
    SELECT 
        employee_id,
        first_name,
        last_name,
        department_id,
        salary,
        RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as dept_rank
    FROM employees
)
SELECT *
FROM ranked_employees
WHERE dept_rank <= 3;

-- Example 2: Running totals with reset
SELECT 
    department_id,
    employee_id,
    salary,
    SUM(salary) OVER (
        PARTITION BY department_id 
        ORDER BY employee_id 
        ROWS UNBOUNDED PRECEDING
    ) as running_total,
    -- Reset running total when department changes
    SUM(salary) OVER (
        PARTITION BY department_id 
        ORDER BY employee_id 
        ROWS UNBOUNDED PRECEDING
    ) - LAG(SUM(salary) OVER (
        PARTITION BY department_id 
        ORDER BY employee_id 
        ROWS UNBOUNDED PRECEDING
    ), 1, 0) OVER (ORDER BY department_id, employee_id) as incremental_total
FROM employees
ORDER BY department_id, employee_id;

-- Example 3: Gaps and Islands problem
WITH salary_gaps AS (
    SELECT 
        employee_id,
        salary,
        LAG(salary) OVER (ORDER BY salary) as prev_salary,
        salary - LAG(salary) OVER (ORDER BY salary) as salary_gap,
        CASE 
            WHEN salary - LAG(salary) OVER (ORDER BY salary) > 5000 THEN 1
            ELSE 0
        END as gap_indicator
    FROM employees
)
SELECT 
    employee_id,
    salary,
    prev_salary,
    salary_gap,
    SUM(gap_indicator) OVER (ORDER BY salary) as group_id
FROM salary_gaps
ORDER BY salary;`
    },
    {
        id: 6,
        category: 'intermediate',
        difficulty: 'intermediate',
        question: 'How do you write a query to find duplicate records in Oracle?',
        answer: 'Use GROUP BY with HAVING clause, or analytical functions like ROW_NUMBER() to identify and handle duplicate records in Oracle.',
        language: 'Oracle SQL',
        code: `-- Method 1: Using GROUP BY and HAVING (shows duplicate values only)
SELECT first_name, last_name, email, COUNT(*) as duplicate_count
FROM employees
GROUP BY first_name, last_name, email
HAVING COUNT(*) > 1;

-- Method 2: Using ROW_NUMBER() to show all duplicate records
SELECT employee_id, first_name, last_name, email, hire_date,
       ROW_NUMBER() OVER (PARTITION BY first_name, last_name, email ORDER BY employee_id) as row_num
FROM employees
WHERE ROW_NUMBER() OVER (PARTITION BY first_name, last_name, email ORDER BY employee_id) > 1;

-- Method 3: Complete duplicate analysis with details
WITH duplicate_analysis AS (
    SELECT 
        employee_id,
        first_name,
        last_name,
        email,
        hire_date,
        salary,
        ROW_NUMBER() OVER (PARTITION BY first_name, last_name, email ORDER BY employee_id) as row_num,
        COUNT(*) OVER (PARTITION BY first_name, last_name, email) as duplicate_count
    FROM employees
)
SELECT 
    employee_id,
    first_name,
    last_name,
    email,
    hire_date,
    salary,
    duplicate_count,
    CASE 
        WHEN row_num = 1 THEN 'KEEP'
        ELSE 'DUPLICATE'
    END as record_status
FROM duplicate_analysis
WHERE duplicate_count > 1
ORDER BY first_name, last_name, email, employee_id;

-- Method 4: Using EXISTS to find records with duplicates
SELECT e1.employee_id, e1.first_name, e1.last_name, e1.email
FROM employees e1
WHERE EXISTS (
    SELECT 1
    FROM employees e2
    WHERE e1.first_name = e2.first_name
      AND e1.last_name = e2.last_name
      AND e1.email = e2.email
      AND e1.employee_id != e2.employee_id
);

-- Method 5: Using MINUS to find unique records
SELECT employee_id, first_name, last_name, email
FROM employees
MINUS
SELECT employee_id, first_name, last_name, email
FROM (
    SELECT employee_id, first_name, last_name, email,
           ROW_NUMBER() OVER (PARTITION BY first_name, last_name, email ORDER BY employee_id) as rn
    FROM employees
)
WHERE rn = 1;

-- Method 6: Advanced duplicate detection with multiple criteria
WITH duplicate_detection AS (
    SELECT 
        employee_id,
        first_name,
        last_name,
        email,
        phone_number,
        -- Check for exact duplicates
        COUNT(*) OVER (PARTITION BY first_name, last_name, email) as exact_duplicates,
        -- Check for potential duplicates (same name, different email)
        COUNT(*) OVER (PARTITION BY first_name, last_name) as name_duplicates,
        -- Check for email duplicates
        COUNT(*) OVER (PARTITION BY email) as email_duplicates,
        -- Check for phone duplicates
        COUNT(*) OVER (PARTITION BY phone_number) as phone_duplicates
    FROM employees
    WHERE email IS NOT NULL
      AND phone_number IS NOT NULL
)
SELECT 
    employee_id,
    first_name,
    last_name,
    email,
    phone_number,
    CASE 
        WHEN exact_duplicates > 1 THEN 'EXACT_DUPLICATE'
        WHEN name_duplicates > 1 AND email_duplicates = 1 THEN 'NAME_DUPLICATE'
        WHEN email_duplicates > 1 THEN 'EMAIL_DUPLICATE'
        WHEN phone_duplicates > 1 THEN 'PHONE_DUPLICATE'
        ELSE 'UNIQUE'
    END as duplicate_type,
    exact_duplicates,
    name_duplicates,
    email_duplicates,
    phone_duplicates
FROM duplicate_detection
WHERE exact_duplicates > 1 
   OR name_duplicates > 1 
   OR email_duplicates > 1 
   OR phone_duplicates > 1
ORDER BY duplicate_type, first_name, last_name;

-- Method 7: Delete duplicates keeping the first occurrence
DELETE FROM employees
WHERE ROWID NOT IN (
    SELECT MIN(ROWID)
    FROM employees
    GROUP BY first_name, last_name, email
);

-- Method 8: Create a clean table without duplicates
CREATE TABLE employees_clean AS
SELECT * FROM (
    SELECT 
        employee_id,
        first_name,
        last_name,
        email,
        hire_date,
        salary,
        ROW_NUMBER() OVER (PARTITION BY first_name, last_name, email ORDER BY employee_id) as rn
    FROM employees
)
WHERE rn = 1;`
    },
    {
        id: 7,
        category: 'advanced',
        difficulty: 'advanced',
        question: 'Find employees who earn more than their department\'s median salary.',
        answer: 'Use Oracle analytical functions like PERCENTILE_CONT to calculate department medians and compare with employee salaries.',
        language: 'Oracle SQL',
        code: `-- Method 1: Using PERCENTILE_CONT for exact median calculation
WITH dept_median AS (
    SELECT 
        department_id,
        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY salary) AS median_salary,
        COUNT(*) as dept_emp_count,
        ROUND(AVG(salary), 2) as avg_salary,
        MIN(salary) as min_salary,
        MAX(salary) as max_salary
    FROM employees
    WHERE salary IS NOT NULL
    GROUP BY department_id
),
employee_analysis AS (
    SELECT 
        e.employee_id,
        e.first_name,
        e.last_name,
        e.salary,
        e.department_id,
        e.hire_date,
        dm.median_salary,
        dm.avg_salary,
        dm.dept_emp_count,
        dm.min_salary,
        dm.max_salary,
        ROUND(e.salary - dm.median_salary, 2) AS salary_above_median,
        ROUND((e.salary / dm.median_salary - 1) * 100, 2) AS pct_above_median
    FROM employees e
    JOIN dept_median dm ON e.department_id = dm.department_id
    WHERE e.salary > dm.median_salary
)
SELECT 
    employee_id,
    first_name,
    last_name,
    salary,
    department_id,
    hire_date,
    median_salary,
    avg_salary,
    salary_above_median,
    pct_above_median || '%' as percentage_above_median,
    CASE 
        WHEN pct_above_median > 50 THEN 'Significantly Above Median'
        WHEN pct_above_median > 25 THEN 'Well Above Median'
        WHEN pct_above_median > 10 THEN 'Above Median'
        ELSE 'Slightly Above Median'
    END as salary_category
FROM employee_analysis
ORDER BY department_id, salary_above_median DESC;

-- Method 2: Using analytical functions with detailed statistics
WITH salary_statistics AS (
    SELECT 
        employee_id,
        first_name,
        last_name,
        salary,
        department_id,
        hire_date,
        -- Calculate median using PERCENTILE_CONT
        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY salary) 
            OVER (PARTITION BY department_id) as median_salary,
        -- Calculate quartiles
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY salary) 
            OVER (PARTITION BY department_id) as q1_salary,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY salary) 
            OVER (PARTITION BY department_id) as q3_salary,
        -- Calculate percentile rank
        PERCENT_RANK() OVER (PARTITION BY department_id ORDER BY salary) as percentile_rank,
        -- Department statistics
        AVG(salary) OVER (PARTITION BY department_id) as dept_avg_salary,
        MIN(salary) OVER (PARTITION BY department_id) as dept_min_salary,
        MAX(salary) OVER (PARTITION BY department_id) as dept_max_salary,
        COUNT(*) OVER (PARTITION BY department_id) as dept_size,
        -- Salary ranking within department
        RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as dept_salary_rank
    FROM employees
    WHERE salary IS NOT NULL
)
SELECT 
    employee_id,
    first_name,
    last_name,
    salary,
    department_id,
    hire_date,
    ROUND(median_salary, 2) as dept_median_salary,
    ROUND(dept_avg_salary, 2) as dept_avg_salary,
    ROUND(q1_salary, 2) as dept_q1_salary,
    ROUND(q3_salary, 2) as dept_q3_salary,
    dept_size,
    dept_salary_rank,
    ROUND(percentile_rank * 100, 1) || '%' as salary_percentile,
    ROUND(salary - median_salary, 2) as amount_above_median,
    ROUND((salary / median_salary - 1) * 100, 2) as pct_above_median,
    CASE 
        WHEN salary >= q3_salary THEN 'Top Quartile'
        WHEN salary >= median_salary THEN 'Above Median'
        WHEN salary >= q1_salary THEN 'Below Median'
        ELSE 'Bottom Quartile'
    END as salary_quartile_position
FROM salary_statistics
WHERE salary > median_salary
ORDER BY department_id, salary DESC;

-- Method 3: Comprehensive analysis with department comparisons
WITH dept_salary_analysis AS (
    SELECT 
        department_id,
        COUNT(*) as emp_count,
        ROUND(AVG(salary), 2) as avg_salary,
        ROUND(MEDIAN(salary), 2) as median_salary,
        ROUND(STDDEV(salary), 2) as salary_stddev,
        MIN(salary) as min_salary,
        MAX(salary) as max_salary,
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY salary) as q1_salary,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY salary) as q3_salary,
        PERCENTILE_CONT(0.9) WITHIN GROUP (ORDER BY salary) as p90_salary
    FROM employees
    WHERE salary IS NOT NULL
    GROUP BY department_id
),
employee_with_stats AS (
    SELECT 
        e.employee_id,
        e.first_name,
        e.last_name,
        e.salary,
        e.department_id,
        e.hire_date,
        e.job_id,
        d.department_name,
        ds.emp_count,
        ds.avg_salary,
        ds.median_salary,
        ds.salary_stddev,
        ds.min_salary,
        ds.max_salary,
        ds.q1_salary,
        ds.q3_salary,
        ds.p90_salary
    FROM employees e
    JOIN departments d ON e.department_id = d.department_id
    JOIN dept_salary_analysis ds ON e.department_id = ds.department_id
    WHERE e.salary IS NOT NULL
)
SELECT 
    employee_id,
    first_name,
    last_name,
    salary,
    department_id,
    department_name,
    job_id,
    hire_date,
    median_salary as dept_median_salary,
    avg_salary as dept_avg_salary,
    emp_count as dept_employee_count,
    ROUND(salary - median_salary, 2) as amount_above_median,
    ROUND((salary / median_salary - 1) * 100, 2) as pct_above_median,
    ROUND((salary - avg_salary) / salary_stddev, 2) as z_score,
    CASE 
        WHEN salary >= p90_salary THEN 'Top 10%'
        WHEN salary >= q3_salary THEN 'Top 25%'
        WHEN salary >= median_salary THEN 'Above Median'
        ELSE 'Below Median'
    END as salary_tier,
    CASE 
        WHEN ABS((salary - avg_salary) / salary_stddev) > 2 THEN 'Outlier'
        WHEN ABS((salary - avg_salary) / salary_stddev) > 1.5 THEN 'Unusual'
        ELSE 'Normal'
    END as salary_distribution_status
FROM employee_with_stats
WHERE salary > median_salary
ORDER BY department_id, (salary / median_salary - 1) DESC;

-- Method 4: Include job title analysis
WITH job_dept_medians AS (
    SELECT 
        department_id,
        job_id,
        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY salary) as job_median_salary,
        COUNT(*) as job_emp_count
    FROM employees
    WHERE salary IS NOT NULL
    GROUP BY department_id, job_id
),
dept_overall_median AS (
    SELECT 
        department_id,
        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY salary) as dept_median_salary
    FROM employees
    WHERE salary IS NOT NULL
    GROUP BY department_id
)
SELECT 
    e.employee_id,
    e.first_name,
    e.last_name,
    e.salary,
    e.department_id,
    e.job_id,
    d.department_name,
    j.job_title,
    dom.dept_median_salary,
    jdm.job_median_salary,
    jdm.job_emp_count,
    ROUND(e.salary - dom.dept_median_salary, 2) as amount_above_dept_median,
    ROUND(e.salary - jdm.job_median_salary, 2) as amount_above_job_median,
    ROUND((e.salary / dom.dept_median_salary - 1) * 100, 2) as pct_above_dept_median,
    ROUND((e.salary / jdm.job_median_salary - 1) * 100, 2) as pct_above_job_median
FROM employees e
JOIN departments d ON e.department_id = d.department_id
JOIN jobs j ON e.job_id = j.job_id
JOIN dept_overall_median dom ON e.department_id = dom.department_id
JOIN job_dept_medians jdm ON e.department_id = jdm.department_id AND e.job_id = jdm.job_id
WHERE e.salary > dom.dept_median_salary
ORDER BY e.department_id, (e.salary / dom.dept_median_salary - 1) DESC;`
    },
    {
        id: 8,
        category: 'advanced',
        difficulty: 'advanced',
        question: 'Write a query to find the top 3 highest-paid employees in each department using Oracle analytical functions.',
        answer: 'Use RANK() or ROW_NUMBER() with PARTITION BY to find top N employees per department, handling ties appropriately.',
        language: 'Oracle SQL',
        code: `-- Method 1: Using RANK() - includes ties
WITH ranked_employees AS (
    SELECT 
        employee_id,
        first_name,
        last_name,
        salary,
        department_id,
        hire_date,
        job_id,
        RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as salary_rank,
        COUNT(*) OVER (PARTITION BY department_id) as dept_total_employees
    FROM employees
    WHERE salary IS NOT NULL
)
SELECT 
    r.employee_id,
    r.first_name,
    r.last_name,
    r.salary,
    r.department_id,
    d.department_name,
    r.job_id,
    j.job_title,
    r.hire_date,
    r.salary_rank,
    r.dept_total_employees
FROM ranked_employees r
JOIN departments d ON r.department_id = d.department_id
JOIN jobs j ON r.job_id = j.job_id
WHERE r.salary_rank <= 3
ORDER BY r.department_id, r.salary_rank;

-- Method 2: Using ROW_NUMBER() - no ties, strict top 3
WITH ranked_employees AS (
    SELECT 
        employee_id,
        first_name,
        last_name,
        salary,
        department_id,
        hire_date,
        job_id,
        ROW_NUMBER() OVER (PARTITION BY department_id ORDER BY salary DESC, hire_date ASC) as row_num
    FROM employees
    WHERE salary IS NOT NULL
)
SELECT 
    r.employee_id,
    r.first_name,
    r.last_name,
    r.salary,
    r.department_id,
    d.department_name,
    r.job_id,
    j.job_title,
    r.hire_date,
    r.row_num as position_in_dept
FROM ranked_employees r
JOIN departments d ON r.department_id = d.department_id
JOIN jobs j ON r.job_id = j.job_id
WHERE r.row_num <= 3
ORDER BY r.department_id, r.row_num;

-- Method 3: Using DENSE_RANK() - better for salary ties
WITH ranked_employees AS (
    SELECT 
        employee_id,
        first_name,
        last_name,
        salary,
        department_id,
        hire_date,
        job_id,
        DENSE_RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as dense_rank,
        RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as regular_rank,
        ROW_NUMBER() OVER (PARTITION BY department_id ORDER BY salary DESC, employee_id) as row_num
    FROM employees
    WHERE salary IS NOT NULL
)
SELECT 
    r.employee_id,
    r.first_name,
    r.last_name,
    r.salary,
    r.department_id,
    d.department_name,
    r.job_id,
    j.job_title,
    r.hire_date,
    r.dense_rank,
    r.regular_rank,
    r.row_num
FROM ranked_employees r
JOIN departments d ON r.department_id = d.department_id
JOIN jobs j ON r.job_id = j.job_id
WHERE r.dense_rank <= 3
ORDER BY r.department_id, r.dense_rank, r.row_num;

-- Method 4: Advanced analysis with additional statistics
WITH dept_salary_stats AS (
    SELECT 
        department_id,
        COUNT(*) as total_employees,
        ROUND(AVG(salary), 2) as avg_salary,
        ROUND(MEDIAN(salary), 2) as median_salary,
        MIN(salary) as min_salary,
        MAX(salary) as max_salary,
        ROUND(STDDEV(salary), 2) as salary_stddev
    FROM employees
    WHERE salary IS NOT NULL
    GROUP BY department_id
),
ranked_employees_detailed AS (
    SELECT 
        e.employee_id,
        e.first_name,
        e.last_name,
        e.salary,
        e.department_id,
        e.hire_date,
        e.job_id,
        e.manager_id,
        RANK() OVER (PARTITION BY e.department_id ORDER BY e.salary DESC) as salary_rank,
        ROUND(e.salary - AVG(e.salary) OVER (PARTITION BY e.department_id), 2) as salary_vs_dept_avg,
        ROUND((e.salary / AVG(e.salary) OVER (PARTITION BY e.department_id) - 1) * 100, 2) as pct_vs_dept_avg,
        ROUND(PERCENT_RANK() OVER (PARTITION BY e.department_id ORDER BY e.salary) * 100, 1) as salary_percentile
    FROM employees e
    WHERE e.salary IS NOT NULL
)
SELECT 
    r.employee_id,
    r.first_name,
    r.last_name,
    r.salary,
    r.department_id,
    d.department_name,
    r.job_id,
    j.job_title,
    r.hire_date,
    CASE 
        WHEN r.manager_id IS NOT NULL THEN 
            (SELECT first_name || ' ' || last_name FROM employees WHERE employee_id = r.manager_id)
        ELSE 'No Manager'
    END as manager_name,
    r.salary_rank,
    r.salary_vs_dept_avg,
    r.pct_vs_dept_avg || '%' as percentage_vs_dept_avg,
    r.salary_percentile || '%' as salary_percentile_in_dept,
    s.total_employees as dept_total_employees,
    s.avg_salary as dept_avg_salary,
    s.median_salary as dept_median_salary,
    s.min_salary as dept_min_salary,
    s.max_salary as dept_max_salary,
    CASE 
        WHEN r.salary_rank = 1 THEN 'Highest Paid'
        WHEN r.salary_rank = 2 THEN 'Second Highest'
        WHEN r.salary_rank = 3 THEN 'Third Highest'
    END as position_description
FROM ranked_employees_detailed r
JOIN departments d ON r.department_id = d.department_id
JOIN jobs j ON r.job_id = j.job_id
JOIN dept_salary_stats s ON r.department_id = s.department_id
WHERE r.salary_rank <= 3
ORDER BY r.department_id, r.salary_rank;

-- Method 5: Include salary gaps analysis
WITH salary_analysis AS (
    SELECT 
        employee_id,
        first_name,
        last_name,
        salary,
        department_id,
        hire_date,
        job_id,
        RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as salary_rank,
        LAG(salary, 1) OVER (PARTITION BY department_id ORDER BY salary DESC) as next_highest_salary,
        LEAD(salary, 1) OVER (PARTITION BY department_id ORDER BY salary DESC) as next_lowest_salary,
        MAX(salary) OVER (PARTITION BY department_id) as dept_max_salary,
        MIN(salary) OVER (PARTITION BY department_id) as dept_min_salary
    FROM employees
    WHERE salary IS NOT NULL
)
SELECT 
    s.employee_id,
    s.first_name,
    s.last_name,
    s.salary,
    s.department_id,
    d.department_name,
    s.job_id,
    j.job_title,
    s.hire_date,
    s.salary_rank,
    s.next_highest_salary,
    s.next_lowest_salary,
    CASE 
        WHEN s.next_highest_salary IS NOT NULL THEN 
            s.next_highest_salary - s.salary
        ELSE NULL
    END as gap_to_higher_salary,
    CASE 
        WHEN s.next_lowest_salary IS NOT NULL THEN 
            s.salary - s.next_lowest_salary
        ELSE NULL
    END as gap_to_lower_salary,
    ROUND((s.salary / s.dept_max_salary) * 100, 2) as pct_of_dept_max
FROM salary_analysis s
JOIN departments d ON s.department_id = d.department_id
JOIN jobs j ON s.job_id = j.job_id
WHERE s.salary_rank <= 3
ORDER BY s.department_id, s.salary_rank;`
    },
    {
        id: 9,
        category: 'advanced',
        difficulty: 'advanced',
        question: 'Create a query to show hierarchical data (employee-manager relationships) in Oracle.',
        answer: 'Use Oracle\'s CONNECT BY clause with START WITH to traverse hierarchical data, along with LEVEL and other hierarchical functions.',
        language: 'Oracle SQL',
        code: `-- Method 1: Basic hierarchical query using CONNECT BY
SELECT 
    LEVEL as hierarchy_level,
    employee_id,
    first_name,
    last_name,
    job_id,
    manager_id,
    salary,
    LPAD(' ', (LEVEL - 1) * 4) || first_name || ' ' || last_name as hierarchy_display
FROM employees
START WITH manager_id IS NULL  -- Start with top-level managers
CONNECT BY PRIOR employee_id = manager_id
ORDER SIBLINGS BY first_name, last_name;

-- Method 2: Comprehensive hierarchical analysis
SELECT 
    LEVEL as hierarchy_level,
    employee_id,
    first_name,
    last_name,
    job_id,
    manager_id,
    salary,
    department_id,
    hire_date,
    -- Hierarchical display with indentation
    LPAD(' ', (LEVEL - 1) * 2) || '‚îî‚îÄ ' || first_name || ' ' || last_name as org_chart,
    -- Path from root to current employee
    SYS_CONNECT_BY_PATH(first_name || ' ' || last_name, ' ‚Üí ') as hierarchy_path,
    -- Is this a leaf node (no subordinates)?
    CONNECT_BY_ISLEAF as is_leaf_node,
    -- Root employee information
    CONNECT_BY_ROOT employee_id as root_employee_id,
    CONNECT_BY_ROOT (first_name || ' ' || last_name) as root_employee_name,
    -- Prior employee (manager) information
    PRIOR employee_id as immediate_manager_id,
    PRIOR (first_name || ' ' || last_name) as immediate_manager_name,
    -- Subordinate count
    (SELECT COUNT(*) FROM employees e2 WHERE e2.manager_id = employees.employee_id) as direct_reports
FROM employees
START WITH manager_id IS NULL
CONNECT BY PRIOR employee_id = manager_id
ORDER SIBLINGS BY job_id, salary DESC;

-- Method 3: Multi-level aggregation in hierarchy
WITH hierarchy_data AS (
    SELECT 
        employee_id,
        first_name,
        last_name,
        salary,
        manager_id,
        department_id,
        job_id,
        LEVEL as emp_level,
        CONNECT_BY_ROOT employee_id as root_id,
        SYS_CONNECT_BY_PATH(employee_id, '/') as path
    FROM employees
    START WITH manager_id IS NULL
    CONNECT BY PRIOR employee_id = manager_id
)
SELECT 
    h.employee_id,
    h.first_name,
    h.last_name,
    h.salary,
    h.manager_id,
    h.department_id,
    d.department_name,
    h.job_id,
    j.job_title,
    h.emp_level,
    -- Manager information
    m.first_name || ' ' || m.last_name as manager_name,
    m.job_id as manager_job_id,
    -- Hierarchy statistics
    (SELECT COUNT(*) FROM hierarchy_data h2 WHERE h2.root_id = h.root_id) as total_in_hierarchy,
    (SELECT COUNT(*) FROM hierarchy_data h2 WHERE h2.manager_id = h.employee_id) as direct_reports,
    (SELECT COUNT(*) FROM hierarchy_data h2 WHERE h2.path LIKE h.path || '%' AND h2.employee_id != h.employee_id) as total_subordinates,
    -- Salary statistics
    (SELECT SUM(salary) FROM hierarchy_data h2 WHERE h2.path LIKE h.path || '%') as total_salary_responsibility,
    (SELECT AVG(salary) FROM hierarchy_data h2 WHERE h2.manager_id = h.employee_id) as avg_direct_report_salary,
    LPAD('  ', (h.emp_level - 1) * 2) || '‚îú‚îÄ ' || h.first_name || ' ' || h.last_name as org_display
FROM hierarchy_data h
LEFT JOIN employees m ON h.manager_id = m.employee_id
LEFT JOIN departments d ON h.department_id = d.department_id
LEFT JOIN jobs j ON h.job_id = j.job_id
ORDER BY h.root_id, h.emp_level, h.salary DESC;

-- Method 4: Finding specific relationships
-- Find all employees under a specific manager
SELECT 
    LEVEL as distance_from_manager,
    employee_id,
    first_name,
    last_name,
    job_id,
    salary,
    manager_id,
    LPAD(' ', (LEVEL - 1) * 4) || first_name || ' ' || last_name as reporting_structure
FROM employees
START WITH employee_id = 100  -- Replace with specific manager ID
CONNECT BY PRIOR employee_id = manager_id
ORDER BY LEVEL, salary DESC;

-- Method 5: Bottom-up hierarchy (from employee to CEO)
SELECT 
    LEVEL as levels_to_top,
    employee_id,
    first_name,
    last_name,
    job_id,
    salary,
    manager_id,
    LPAD(' ', (LEVEL - 1) * 4) || first_name || ' ' || last_name as management_chain
FROM employees
START WITH employee_id = 107  -- Replace with specific employee ID
CONNECT BY employee_id = PRIOR manager_id  -- Note: reversed relationship
ORDER BY LEVEL;

-- Method 6: Hierarchical aggregations and span of control
WITH org_hierarchy AS (
    SELECT 
        employee_id,
        first_name,
        last_name,
        manager_id,
        salary,
        department_id,
        job_id,
        hire_date,
        LEVEL as org_level,
        CONNECT_BY_ROOT employee_id as ceo_id,
        SYS_CONNECT_BY_PATH(employee_id, '/') as emp_path,
        CONNECT_BY_ISLEAF as is_individual_contributor
    FROM employees
    START WITH manager_id IS NULL
    CONNECT BY PRIOR employee_id = manager_id
),
manager_stats AS (
    SELECT 
        manager_id,
        COUNT(*) as direct_reports,
        AVG(salary) as avg_direct_salary,
        MIN(salary) as min_direct_salary,
        MAX(salary) as max_direct_salary,
        SUM(salary) as total_direct_salary
    FROM employees
    WHERE manager_id IS NOT NULL
    GROUP BY manager_id
)
SELECT 
    oh.employee_id,
    oh.first_name,
    oh.last_name,
    oh.salary,
    oh.department_id,
    oh.job_id,
    oh.hire_date,
    oh.org_level,
    oh.manager_id,
    -- Manager statistics
    COALESCE(ms.direct_reports, 0) as direct_reports_count,
    COALESCE(ms.avg_direct_salary, 0) as avg_direct_report_salary,
    COALESCE(ms.total_direct_salary, 0) as total_direct_salary_managed,
    -- Span of control analysis
    CASE 
        WHEN COALESCE(ms.direct_reports, 0) = 0 THEN 'Individual Contributor'
        WHEN ms.direct_reports <= 3 THEN 'Small Team Manager'
        WHEN ms.direct_reports <= 7 THEN 'Medium Team Manager'
        WHEN ms.direct_reports <= 15 THEN 'Large Team Manager'
        ELSE 'Very Large Team Manager'
    END as management_category,
    -- Subordinate count at all levels
    (SELECT COUNT(*) 
     FROM org_hierarchy oh2 
     WHERE oh2.emp_path LIKE oh.emp_path || '%' 
     AND oh2.employee_id != oh.employee_id) as total_subordinates,
    -- Hierarchy display
    LPAD(' ', (oh.org_level - 1) * 3) || 
    CASE 
        WHEN oh.is_individual_contributor = 1 THEN '‚îî‚îÄ '
        ELSE '‚îú‚îÄ '
    END || oh.first_name || ' ' || oh.last_name || 
    ' (' || COALESCE(ms.direct_reports, 0) || ' reports)' as org_chart_display
FROM org_hierarchy oh
LEFT JOIN manager_stats ms ON oh.employee_id = ms.manager_id
ORDER BY oh.org_level, oh.department_id, oh.salary DESC;

-- Method 7: Find cycles in hierarchy (error detection)
SELECT 
    employee_id,
    first_name,
    last_name,
    manager_id,
    'Potential Cycle Detected' as issue
FROM employees
WHERE CONNECT_BY_ISCYCLE = 1
START WITH manager_id IS NULL
CONNECT BY NOCYCLE PRIOR employee_id = manager_id;`
    },
    {
        id: 10,
        category: 'advanced',
        difficulty: 'advanced',
        question: 'Write a query to calculate running totals and moving averages in Oracle.',
        answer: 'Use Oracle analytical functions with window frames to calculate running totals, moving averages, and other windowing calculations.',
        language: 'Oracle SQL',
        code: `-- Comprehensive Running Totals and Moving Averages
SELECT 
    employee_id,
    first_name,
    last_name,
    department_id,
    salary,
    hire_date,
    
    -- RUNNING TOTALS
    -- Simple running total ordered by hire_date
    SUM(salary) OVER (ORDER BY hire_date) as running_total_salary,
    
    -- Running total within department
    SUM(salary) OVER (PARTITION BY department_id ORDER BY hire_date) as dept_running_total,
    
    -- Running total with specific window frame
    SUM(salary) OVER (
        ORDER BY hire_date 
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) as running_total_explicit,
    
    -- MOVING AVERAGES
    -- 3-employee moving average
    AVG(salary) OVER (
        ORDER BY hire_date 
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) as moving_avg_3_employees,
    
    -- 5-employee moving average
    AVG(salary) OVER (
        ORDER BY hire_date 
        ROWS BETWEEN 4 PRECEDING AND CURRENT ROW
    ) as moving_avg_5_employees,
    
    -- Centered moving average (2 before, current, 2 after)
    AVG(salary) OVER (
        ORDER BY hire_date 
        ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING
    ) as centered_moving_avg,
    
    -- Moving average within department
    AVG(salary) OVER (
        PARTITION BY department_id 
        ORDER BY hire_date 
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) as dept_moving_avg,
    
    -- RANGE-based windows (time-based)
    -- Average salary for employees hired in the last 365 days
    AVG(salary) OVER (
        ORDER BY hire_date 
        RANGE BETWEEN INTERVAL '365' DAY PRECEDING AND CURRENT ROW
    ) as avg_salary_last_year,
    
    -- Sum of salaries for employees hired in the last 6 months
    SUM(salary) OVER (
        ORDER BY hire_date 
        RANGE BETWEEN INTERVAL '6' MONTH PRECEDING AND CURRENT ROW
    ) as sum_salary_last_6_months,
    
    -- RUNNING STATISTICS
    -- Running count
    COUNT(*) OVER (ORDER BY hire_date) as running_count,
    
    -- Running minimum and maximum
    MIN(salary) OVER (ORDER BY hire_date) as running_min_salary,
    MAX(salary) OVER (ORDER BY hire_date) as running_max_salary,
    
    -- Running standard deviation
    STDDEV(salary) OVER (
        ORDER BY hire_date 
        ROWS BETWEEN 4 PRECEDING AND CURRENT ROW
    ) as running_stddev_5,
    
    -- FIRST_VALUE and LAST_VALUE in windows
    FIRST_VALUE(salary) OVER (
        ORDER BY hire_date 
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) as first_salary_in_window,
    
    LAST_VALUE(salary) OVER (
        ORDER BY hire_date 
        ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING
    ) as last_salary_in_window
    
FROM employees
WHERE salary IS NOT NULL
ORDER BY hire_date;

-- Advanced example: Sales analysis with multiple window functions
WITH daily_sales AS (
    SELECT 
        sale_date,
        customer_id,
        product_id,
        quantity,
        unit_price,
        quantity * unit_price as total_amount,
        region_id
    FROM sales
    WHERE sale_date >= SYSDATE - 90  -- Last 90 days
),
aggregated_daily AS (
    SELECT 
        sale_date,
        region_id,
        SUM(total_amount) as daily_sales,
        COUNT(*) as daily_transactions,
        AVG(total_amount) as avg_transaction_amount
    FROM daily_sales
    GROUP BY sale_date, region_id
)
SELECT 
    sale_date,
    region_id,
    daily_sales,
    daily_transactions,
    avg_transaction_amount,
    
    -- Running totals
    SUM(daily_sales) OVER (
        PARTITION BY region_id 
        ORDER BY sale_date
    ) as running_total_sales,
    
    -- 7-day moving average
    AVG(daily_sales) OVER (
        PARTITION BY region_id 
        ORDER BY sale_date 
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) as moving_avg_7_days,
    
    -- 30-day moving average
    AVG(daily_sales) OVER (
        PARTITION BY region_id 
        ORDER BY sale_date 
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) as moving_avg_30_days,
    
    -- Exponential moving average (approximate)
    AVG(daily_sales) OVER (
        PARTITION BY region_id 
        ORDER BY sale_date 
        ROWS BETWEEN 13 PRECEDING AND CURRENT ROW
    ) as ema_approx_14_days,
    
    -- Growth calculations
    daily_sales - LAG(daily_sales, 1) OVER (
        PARTITION BY region_id 
        ORDER BY sale_date
    ) as daily_growth,
    
    -- 7-day growth
    daily_sales - LAG(daily_sales, 7) OVER (
        PARTITION BY region_id 
        ORDER BY sale_date
    ) as weekly_growth,
    
    -- Percentage growth
    ROUND(
        (daily_sales - LAG(daily_sales, 1) OVER (
            PARTITION BY region_id 
            ORDER BY sale_date
        )) / NULLIF(LAG(daily_sales, 1) OVER (
            PARTITION BY region_id 
            ORDER BY sale_date
        ), 0) * 100, 2
    ) as daily_growth_pct,
    
    -- Rolling minimum and maximum
    MIN(daily_sales) OVER (
        PARTITION BY region_id 
        ORDER BY sale_date 
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) as rolling_min_7_days,
    
    MAX(daily_sales) OVER (
        PARTITION BY region_id 
        ORDER BY sale_date 
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) as rolling_max_7_days,
    
    -- Volatility (standard deviation)
    STDDEV(daily_sales) OVER (
        PARTITION BY region_id 
        ORDER BY sale_date 
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) as volatility_30_days,
    
    -- Percentile calculations
    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY daily_sales) OVER (
        PARTITION BY region_id 
        ORDER BY sale_date 
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) as median_7_days
    
FROM aggregated_daily
ORDER BY region_id, sale_date;

-- Employee salary analysis with advanced windowing
WITH salary_analysis AS (
    SELECT 
        employee_id,
        first_name,
        last_name,
        department_id,
        salary,
        hire_date,
        job_id,
        -- Calculate years of service
        ROUND(MONTHS_BETWEEN(SYSDATE, hire_date) / 12, 2) as years_of_service
    FROM employees
    WHERE salary IS NOT NULL
)
SELECT 
    employee_id,
    first_name,
    last_name,
    department_id,
    salary,
    hire_date,
    years_of_service,
    
    -- Running statistics by hire date
    COUNT(*) OVER (ORDER BY hire_date) as hire_sequence,
    
    AVG(salary) OVER (
        ORDER BY hire_date 
        ROWS BETWEEN 4 PRECEDING AND CURRENT ROW
    ) as avg_salary_last_5_hires,
    
    -- Department-specific running statistics
    COUNT(*) OVER (
        PARTITION BY department_id 
        ORDER BY hire_date
    ) as dept_hire_sequence,
    
    AVG(salary) OVER (
        PARTITION BY department_id 
        ORDER BY hire_date
    ) as dept_running_avg_salary,
    
    -- Salary percentile within department
    PERCENT_RANK() OVER (
        PARTITION BY department_id 
        ORDER BY salary
    ) as salary_percentile_in_dept,
    
    -- Years of service analysis
    AVG(years_of_service) OVER (
        ORDER BY hire_date 
        ROWS BETWEEN 9 PRECEDING AND CURRENT ROW
    ) as avg_tenure_last_10_hires,
    
    -- Salary growth potential (compared to senior employees)
    AVG(salary) OVER (
        PARTITION BY department_id 
        ORDER BY years_of_service DESC
        ROWS BETWEEN CURRENT ROW AND 4 FOLLOWING
    ) as avg_salary_senior_5_in_dept,
    
    -- Historical context
    FIRST_VALUE(salary) OVER (
        PARTITION BY department_id 
        ORDER BY hire_date 
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) as first_hire_salary_in_dept,
    
    LAST_VALUE(salary) OVER (
        PARTITION BY department_id 
        ORDER BY hire_date 
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) as latest_hire_salary_in_dept
    
FROM salary_analysis
ORDER BY department_id, hire_date;`
    },
    {
        id: 11,
        category: 'basic',
        difficulty: 'basic',
        question: 'What are the different types of JOINs in Oracle and when to use them?',
        answer: 'Oracle supports multiple JOIN types: INNER JOIN, LEFT/RIGHT/FULL OUTER JOIN, CROSS JOIN, and NATURAL JOIN. Each serves different purposes for combining data from multiple tables.',
        language: 'Oracle SQL',
        code: `-- INNER JOIN: Returns only matching records from both tables
SELECT 
    e.employee_id,
    e.first_name,
    e.last_name,
    d.department_name,
    j.job_title
FROM employees e
INNER JOIN departments d ON e.department_id = d.department_id
INNER JOIN jobs j ON e.job_id = j.job_id;

-- LEFT OUTER JOIN: Returns all records from left table, matching from right
SELECT 
    e.employee_id,
    e.first_name,
    e.last_name,
    d.department_name,
    COALESCE(d.department_name, 'No Department') as dept_display
FROM employees e
LEFT OUTER JOIN departments d ON e.department_id = d.department_id;

-- RIGHT OUTER JOIN: Returns all records from right table, matching from left
SELECT 
    e.employee_id,
    e.first_name,
    e.last_name,
    d.department_name,
    d.location_id
FROM employees e
RIGHT OUTER JOIN departments d ON e.department_id = d.department_id;

-- FULL OUTER JOIN: Returns all records from both tables
SELECT 
    e.employee_id,
    e.first_name,
    e.last_name,
    d.department_name,
    CASE 
        WHEN e.employee_id IS NULL THEN 'Department with no employees'
        WHEN d.department_id IS NULL THEN 'Employee with no department'
        ELSE 'Matched record'
    END as join_status
FROM employees e
FULL OUTER JOIN departments d ON e.department_id = d.department_id;

-- CROSS JOIN: Cartesian product of both tables
SELECT 
    e.first_name,
    e.last_name,
    d.department_name,
    COUNT(*) OVER () as total_combinations
FROM employees e
CROSS JOIN departments d
WHERE ROWNUM <= 20;  -- Limit results for demonstration

-- NATURAL JOIN: Automatically joins on columns with same name
SELECT 
    employee_id,
    first_name,
    last_name,
    department_id,
    department_name
FROM employees
NATURAL JOIN departments;

-- SELF JOIN: Joining table with itself
SELECT 
    emp.employee_id,
    emp.first_name || ' ' || emp.last_name as employee_name,
    emp.job_id as employee_job,
    mgr.employee_id as manager_id,
    mgr.first_name || ' ' || mgr.last_name as manager_name,
    mgr.job_id as manager_job
FROM employees emp
LEFT JOIN employees mgr ON emp.manager_id = mgr.employee_id
ORDER BY emp.department_id, emp.employee_id;

-- Advanced JOIN examples
-- Multiple table joins with conditions
SELECT 
    e.employee_id,
    e.first_name,
    e.last_name,
    d.department_name,
    j.job_title,
    l.city,
    l.country_id,
    c.country_name,
    e.salary
FROM employees e
INNER JOIN departments d ON e.department_id = d.department_id
INNER JOIN jobs j ON e.job_id = j.job_id
INNER JOIN locations l ON d.location_id = l.location_id
INNER JOIN countries c ON l.country_id = c.country_id
WHERE e.salary > 50000
ORDER BY c.country_name, d.department_name, e.salary DESC;

-- JOIN with aggregation
SELECT 
    d.department_name,
    COUNT(e.employee_id) as employee_count,
    AVG(e.salary) as avg_salary,
    MIN(e.salary) as min_salary,
    MAX(e.salary) as max_salary,
    SUM(e.salary) as total_salary
FROM departments d
LEFT JOIN employees e ON d.department_id = e.department_id
GROUP BY d.department_id, d.department_name
ORDER BY employee_count DESC;

-- Complex JOIN with subqueries
SELECT 
    e.employee_id,
    e.first_name,
    e.last_name,
    e.salary,
    d.department_name,
    dept_stats.avg_dept_salary,
    dept_stats.employee_count,
    ROUND(e.salary - dept_stats.avg_dept_salary, 2) as salary_vs_dept_avg
FROM employees e
INNER JOIN departments d ON e.department_id = d.department_id
INNER JOIN (
    SELECT 
        department_id,
        AVG(salary) as avg_dept_salary,
        COUNT(*) as employee_count
    FROM employees
    GROUP BY department_id
) dept_stats ON e.department_id = dept_stats.department_id
WHERE e.salary > dept_stats.avg_dept_salary
ORDER BY e.department_id, e.salary DESC;

-- JOIN with window functions
SELECT 
    e.employee_id,
    e.first_name,
    e.last_name,
    d.department_name,
    e.salary,
    AVG(e.salary) OVER (PARTITION BY d.department_id) as dept_avg_salary,
    RANK() OVER (PARTITION BY d.department_id ORDER BY e.salary DESC) as salary_rank_in_dept,
    COUNT(*) OVER (PARTITION BY d.department_id) as dept_employee_count
FROM employees e
INNER JOIN departments d ON e.department_id = d.department_id
ORDER BY d.department_name, salary_rank_in_dept;`


            
},
    {
        id: 12,
        category: 'intermediate',
        difficulty: 'intermediate',
        question: 'How do you use subqueries in Oracle SQL? Provide examples of correlated and non-correlated subqueries.',
        answer: 'Subqueries are queries nested inside another query. They can be correlated (reference outer query) or non-correlated (independent). Used in SELECT, WHERE, FROM, and HAVING clauses.',
        language: 'Oracle SQL',
        code: `-- NON-CORRELATED SUBQUERIES
-- Subquery in WHERE clause
SELECT employee_id, first_name, last_name, salary
FROM employees
WHERE salary > (
    SELECT AVG(salary)
    FROM employees
);

-- Subquery in FROM clause (inline view)
SELECT 
    dept_summary.department_name,
    dept_summary.avg_salary,
    dept_summary.employee_count,
    dept_summary.total_salary
FROM (
    SELECT 
        d.department_name,
        AVG(e.salary) as avg_salary,
        COUNT(e.employee_id) as employee_count,
        SUM(e.salary) as total_salary
    FROM departments d
    LEFT JOIN employees e ON d.department_id = e.department_id
    GROUP BY d.department_id, d.department_name
) dept_summary
WHERE dept_summary.employee_count > 5
ORDER BY dept_summary.avg_salary DESC;

-- Subquery in SELECT clause
SELECT 
    employee_id,
    first_name,
    last_name,
    salary,
    department_id,
    (SELECT department_name FROM departments WHERE department_id = employees.department_id) as department_name,
    (SELECT AVG(salary) FROM employees e2 WHERE e2.department_id = employees.department_id) as dept_avg_salary
FROM employees
ORDER BY department_id, salary DESC;

-- CORRELATED SUBQUERIES
-- Find employees earning more than average in their department
SELECT 
    employee_id,
    first_name,
    last_name,
    salary,
    department_id
FROM employees e1
WHERE salary > (
    SELECT AVG(salary)
    FROM employees e2
    WHERE e2.department_id = e1.department_id
);

-- Find employees with highest salary in each department
SELECT 
    employee_id,
    first_name,
    last_name,
    salary,
    department_id
FROM employees e1
WHERE salary = (
    SELECT MAX(salary)
    FROM employees e2
    WHERE e2.department_id = e1.department_id
);

-- EXISTS subquery - find departments with employees
SELECT 
    department_id,
    department_name
FROM departments d
WHERE EXISTS (
    SELECT 1
    FROM employees e
    WHERE e.department_id = d.department_id
);

-- NOT EXISTS subquery - find departments without employees
SELECT 
    department_id,
    department_name
FROM departments d
WHERE NOT EXISTS (
    SELECT 1
    FROM employees e
    WHERE e.department_id = d.department_id
);

-- Multiple column subquery
SELECT 
    employee_id,
    first_name,
    last_name,
    salary,
    department_id
FROM employees
WHERE (department_id, salary) IN (
    SELECT department_id, MAX(salary)
    FROM employees
    GROUP BY department_id
);

-- Advanced correlated subquery with ranking
SELECT 
    employee_id,
    first_name,
    last_name,
    salary,
    department_id,
    (SELECT COUNT(*) 
     FROM employees e2 
     WHERE e2.department_id = e1.department_id 
     AND e2.salary >= e1.salary) as salary_rank
FROM employees e1
ORDER BY department_id, salary_rank;

-- Subquery with analytical functions
SELECT 
    employee_id,
    first_name,
    last_name,
    salary,
    department_id,
    hire_date
FROM employees e1
WHERE hire_date = (
    SELECT MIN(hire_date)
    FROM employees e2
    WHERE e2.department_id = e1.department_id
);

-- Complex nested subqueries
SELECT 
    employee_id,
    first_name,
    last_name,
    salary,
    department_id
FROM employees
WHERE employee_id IN (
    SELECT employee_id
    FROM employees
    WHERE department_id IN (
        SELECT department_id
        FROM departments
        WHERE location_id IN (
            SELECT location_id
            FROM locations
            WHERE country_id = 'US'
        )
    )
    AND salary > (
        SELECT AVG(salary)
        FROM employees
        WHERE department_id = employees.department_id
    )
);

-- Using subqueries for data validation
-- Find employees with invalid department references
SELECT 
    employee_id,
    first_name,
    last_name,
    department_id
FROM employees
WHERE department_id NOT IN (
    SELECT department_id
    FROM departments
    WHERE department_id IS NOT NULL
);

-- Subquery with CASE statement
SELECT 
    employee_id,
    first_name,
    last_name,
    salary,
    department_id,
    CASE 
        WHEN salary > (
            SELECT AVG(salary)
            FROM employees e2
            WHERE e2.department_id = employees.department_id
        ) THEN 'Above Average'
        WHEN salary < (
            SELECT AVG(salary)
            FROM employees e2
            WHERE e2.department_id = employees.department_id
        ) THEN 'Below Average'
        ELSE 'Average'
    END as salary_category
FROM employees
ORDER BY department_id, salary DESC;

-- Subquery in UPDATE statement
UPDATE employees
SET salary = salary * 1.1
WHERE department_id IN (
    SELECT department_id
    FROM departments
    WHERE department_name IN ('IT', 'Sales')
);

-- Subquery in DELETE statement
DELETE FROM employees
WHERE employee_id IN (
    SELECT employee_id
    FROM employees
    WHERE hire_date < (
        SELECT ADD_MONTHS(SYSDATE, -120)  -- 10 years ago
        FROM dual
    )
    AND department_id IN (
        SELECT department_id
        FROM departments
        WHERE department_name = 'Archive'
    )
);

-- WITH clause (Common Table Expression) - alternative to subqueries
WITH 
dept_stats AS (
    SELECT 
        department_id,
        AVG(salary) as avg_salary,
        COUNT(*) as emp_count,
        MAX(salary) as max_salary
    FROM employees
    GROUP BY department_id
),
high_performing_depts AS (
    SELECT department_id
    FROM dept_stats
    WHERE avg_salary > 60000
    AND emp_count > 3
)
SELECT 
    e.employee_id,
    e.first_name,
    e.last_name,
    e.salary,
    d.department_name,
    ds.avg_salary as dept_avg_salary,
    ds.emp_count as dept_employee_count
FROM employees e
JOIN departments d ON e.department_id = d.department_id
JOIN dept_stats ds ON e.department_id = ds.department_id
WHERE e.department_id IN (SELECT department_id FROM high_performing_depts)
ORDER BY e.department_id, e.salary DESC;`
    },
    {
        id: 13,
        category: 'intermediate',
        difficulty: 'intermediate',
        question: 'What are Common Table Expressions (CTEs) in Oracle and how do they differ from subqueries?',
        answer: 'CTEs use the WITH clause to create temporary named result sets that can be referenced multiple times in a query. They improve readability and can be recursive, unlike regular subqueries.',
        language: 'Oracle SQL',
        code: `-- Basic CTE example
WITH high_salary_employees AS (
    SELECT 
        employee_id,
        first_name,
        last_name,
        salary,
        department_id
    FROM employees
    WHERE salary > 50000
)
SELECT 
    hse.employee_id,
    hse.first_name,
    hse.last_name,
    hse.salary,
    d.department_name
FROM high_salary_employees hse
JOIN departments d ON hse.department_id = d.department_id
ORDER BY hse.salary DESC;

-- Multiple CTEs in single query
WITH 
dept_stats AS (
    SELECT 
        department_id,
        COUNT(*) as employee_count,
        AVG(salary) as avg_salary,
        MIN(salary) as min_salary,
        MAX(salary) as max_salary,
        SUM(salary) as total_salary
    FROM employees
    GROUP BY department_id
),
dept_rankings AS (
    SELECT 
        department_id,
        employee_count,
        avg_salary,
        RANK() OVER (ORDER BY avg_salary DESC) as salary_rank,
        RANK() OVER (ORDER BY employee_count DESC) as size_rank
    FROM dept_stats
),
top_departments AS (
    SELECT department_id
    FROM dept_rankings
    WHERE salary_rank <= 3 OR size_rank <= 3
)
SELECT 
    d.department_name,
    ds.employee_count,
    ds.avg_salary,
    ds.total_salary,
    dr.salary_rank,
    dr.size_rank,
    CASE 
        WHEN dr.salary_rank <= 3 AND dr.size_rank <= 3 THEN 'Top in Both'
        WHEN dr.salary_rank <= 3 THEN 'Top by Salary'
        WHEN dr.size_rank <= 3 THEN 'Top by Size'
    END as ranking_category
FROM departments d
JOIN dept_stats ds ON d.department_id = ds.department_id
JOIN dept_rankings dr ON d.department_id = dr.department_id
WHERE d.department_id IN (SELECT department_id FROM top_departments)
ORDER BY dr.salary_rank, dr.size_rank;

-- Recursive CTE for hierarchical data
WITH employee_hierarchy AS (
    -- Anchor member: start with top-level managers
    SELECT 
        employee_id,
        first_name,
        last_name,
        manager_id,
        job_id,
        salary,
        1 as level,
        first_name || ' ' || last_name as hierarchy_path
    FROM employees
    WHERE manager_id IS NULL
    
    UNION ALL
    
    -- Recursive member: add subordinates
    SELECT 
        e.employee_id,
        e.first_name,
        e.last_name,
        e.manager_id,
        e.job_id,
        e.salary,
        eh.level + 1,
        eh.hierarchy_path || ' -> ' || e.first_name || ' ' || e.last_name
    FROM employees e
    INNER JOIN employee_hierarchy eh ON e.manager_id = eh.employee_id
    WHERE eh.level < 10  -- Prevent infinite recursion
)
SELECT 
    employee_id,
    first_name,
    last_name,
    manager_id,
    job_id,
    salary,
    level,
    hierarchy_path,
    LPAD(' ', (level - 1) * 4) || first_name || ' ' || last_name as indented_name
FROM employee_hierarchy
ORDER BY hierarchy_path;

-- CTE with window functions for advanced analytics
WITH 
monthly_sales AS (
    SELECT 
        EXTRACT(YEAR FROM order_date) as year,
        EXTRACT(MONTH FROM order_date) as month,
        SUM(order_total) as monthly_total,
        COUNT(*) as order_count
    FROM orders
    WHERE order_date >= ADD_MONTHS(SYSDATE, -24)
    GROUP BY EXTRACT(YEAR FROM order_date), EXTRACT(MONTH FROM order_date)
),
sales_with_trends AS (
    SELECT 
        year,
        month,
        monthly_total,
        order_count,
        LAG(monthly_total, 1) OVER (ORDER BY year, month) as prev_month_sales,
        LAG(monthly_total, 12) OVER (ORDER BY year, month) as same_month_prev_year,
        AVG(monthly_total) OVER (ORDER BY year, month ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) as three_month_avg,
        SUM(monthly_total) OVER (ORDER BY year, month ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) as rolling_12_month_total
    FROM monthly_sales
)
SELECT 
    year,
    month,
    TO_CHAR(TO_DATE(month, 'MM'), 'Month') as month_name,
    monthly_total,
    order_count,
    prev_month_sales,
    same_month_prev_year,
    three_month_avg,
    rolling_12_month_total,
    CASE 
        WHEN prev_month_sales IS NOT NULL THEN
            ROUND((monthly_total - prev_month_sales) / prev_month_sales * 100, 2)
        ELSE NULL
    END as mom_growth_pct,
    CASE 
        WHEN same_month_prev_year IS NOT NULL THEN
            ROUND((monthly_total - same_month_prev_year) / same_month_prev_year * 100, 2)
        ELSE NULL
    END as yoy_growth_pct
FROM sales_with_trends
ORDER BY year, month;

-- Complex CTE for employee performance analysis
WITH 
employee_metrics AS (
    SELECT 
        e.employee_id,
        e.first_name,
        e.last_name,
        e.department_id,
        e.job_id,
        e.salary,
        e.hire_date,
        MONTHS_BETWEEN(SYSDATE, e.hire_date) / 12 as years_of_service,
        -- Performance metrics (assuming these tables exist)
        COALESCE(p.performance_rating, 3) as performance_rating,
        COALESCE(p.goals_met, 0) as goals_met,
        COALESCE(p.total_goals, 1) as total_goals
    FROM employees e
    LEFT JOIN performance_reviews p ON e.employee_id = p.employee_id 
        AND p.review_year = EXTRACT(YEAR FROM SYSDATE)
),
department_benchmarks AS (
    SELECT 
        department_id,
        AVG(salary) as avg_dept_salary,
        AVG(years_of_service) as avg_tenure,
        AVG(performance_rating) as avg_performance,
        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY salary) as median_salary,
        COUNT(*) as dept_size
    FROM employee_metrics
    GROUP BY department_id
),
employee_scores AS (
    SELECT 
        em.*,
        db.avg_dept_salary,
        db.avg_tenure,
        db.avg_performance,
        db.median_salary,
        db.dept_size,
        -- Scoring calculations
        CASE 
            WHEN em.salary >= db.median_salary THEN 1 ELSE 0
        END as salary_score,
        CASE 
            WHEN em.performance_rating >= db.avg_performance THEN 1 ELSE 0
        END as performance_score,
        CASE 
            WHEN em.years_of_service >= db.avg_tenure THEN 1 ELSE 0
        END as tenure_score,
        CASE 
            WHEN em.goals_met / em.total_goals >= 0.8 THEN 1 ELSE 0
        END as goals_score
    FROM employee_metrics em
    JOIN department_benchmarks db ON em.department_id = db.department_id
)
SELECT 
    employee_id,
    first_name,
    last_name,
    department_id,
    salary,
    performance_rating,
    years_of_service,
    goals_met,
    total_goals,
    ROUND(goals_met / total_goals * 100, 1) as goals_completion_pct,
    salary_score + performance_score + tenure_score + goals_score as total_score,
    CASE 
        WHEN salary_score + performance_score + tenure_score + goals_score >= 3 THEN 'High Performer'
        WHEN salary_score + performance_score + tenure_score + goals_score >= 2 THEN 'Good Performer'
        ELSE 'Needs Improvement'
    END as performance_category,
    RANK() OVER (PARTITION BY department_id ORDER BY salary_score + performance_score + tenure_score + goals_score DESC) as dept_rank
FROM employee_scores
ORDER BY department_id, total_score DESC;

-- CTE vs Subquery Performance Comparison
-- Using subquery (less readable, potentially less efficient)
SELECT 
    e.employee_id,
    e.first_name,
    e.last_name,
    e.salary,
    (SELECT AVG(salary) FROM employees WHERE department_id = e.department_id) as dept_avg,
    (SELECT COUNT(*) FROM employees WHERE department_id = e.department_id) as dept_count
FROM employees e
WHERE e.salary > (
    SELECT AVG(salary) 
    FROM employees 
    WHERE department_id = e.department_id
);

-- Same query using CTE (more readable, potentially more efficient)
WITH dept_stats AS (
    SELECT 
        department_id,
        AVG(salary) as avg_salary,
        COUNT(*) as employee_count
    FROM employees
    GROUP BY department_id
)
SELECT 
    e.employee_id,
    e.first_name,
    e.last_name,
    e.salary,
    ds.avg_salary as dept_avg,
    ds.employee_count as dept_count
FROM employees e
JOIN dept_stats ds ON e.department_id = ds.department_id
WHERE e.salary > ds.avg_salary;

-- Recursive CTE for finding all paths in hierarchy
WITH employee_paths AS (
    -- Start with each employee
    SELECT 
        employee_id,
        manager_id,
        first_name || ' ' || last_name as employee_name,
        first_name || ' ' || last_name as path,
        1 as level
    FROM employees
    
    UNION ALL
    
    -- Add each manager level
    SELECT 
        mp.employee_id,
        e.manager_id,
        mp.employee_name,
        e.first_name || ' ' || e.last_name || ' -> ' || mp.path as path,
        mp.level + 1
    FROM employee_paths mp
    JOIN employees e ON mp.manager_id = e.employee_id
    WHERE mp.level < 10
)
SELECT 
    employee_id,
    employee_name,
    path as management_chain,
    level as chain_length
FROM employee_paths
WHERE manager_id IS NULL  -- Only show complete paths to top
ORDER BY employee_id;`
    },



    {
        id: 14,
        category: 'advanced',
        difficulty: 'advanced',
        question: 'How do you optimize Oracle SQL queries for better performance?',
        answer: 'Oracle SQL optimization involves proper indexing, query restructuring, hint usage, execution plan analysis, and understanding Oracle\'s cost-based optimizer.',
        language: 'Oracle SQL',
        code: `-- 1. EXECUTION PLAN ANALYSIS
-- Always check execution plans before optimizing
EXPLAIN PLAN FOR
SELECT e.employee_id, e.first_name, e.last_name, d.department_name
FROM employees e
JOIN departments d ON e.department_id = d.department_id
WHERE e.salary > 50000;

-- View the execution plan
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-- Get actual execution statistics
SELECT /*+ GATHER_PLAN_STATISTICS */ 
    e.employee_id, e.first_name, e.last_name, d.department_name
FROM employees e
JOIN departments d ON e.department_id = d.department_id
WHERE e.salary > 50000;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL, NULL, 'ALLSTATS LAST'));

-- 2. INDEXING STRATEGIES
-- Create composite index for common query patterns
CREATE INDEX idx_emp_dept_salary ON employees(department_id, salary);
CREATE INDEX idx_emp_name ON employees(last_name, first_name);
CREATE INDEX idx_emp_hire_date ON employees(hire_date);

-- Function-based index for case-insensitive searches
CREATE INDEX idx_emp_upper_lastname ON employees(UPPER(last_name));

-- Partial index for specific conditions
CREATE INDEX idx_emp_active_high_salary ON employees(salary) 
WHERE status = 'ACTIVE' AND salary > 50000;

-- 3. QUERY OPTIMIZATION TECHNIQUES
-- Bad: Using functions in WHERE clause prevents index usage
SELECT * FROM employees 
WHERE UPPER(last_name) = 'SMITH';

-- Good: Use function-based index or avoid functions
SELECT * FROM employees 
WHERE last_name = 'Smith';

-- Bad: Leading wildcard prevents index usage
SELECT * FROM employees 
WHERE last_name LIKE '%son';

-- Good: Use proper wildcards
SELECT * FROM employees 
WHERE last_name LIKE 'John%';

-- Bad: Using OR can be inefficient
SELECT * FROM employees 
WHERE department_id = 10 OR department_id = 20;

-- Good: Use IN clause
SELECT * FROM employees 
WHERE department_id IN (10, 20);

-- Even better: Use UNION ALL if selectivity is high
SELECT * FROM employees WHERE department_id = 10
UNION ALL
SELECT * FROM employees WHERE department_id = 20;

-- 4. HINT USAGE FOR PERFORMANCE TUNING
-- Force index usage
SELECT /*+ INDEX(e idx_emp_dept_salary) */
    employee_id, first_name, last_name, salary
FROM employees e
WHERE department_id = 10 AND salary > 50000;

-- Force specific join method
SELECT /*+ USE_HASH(e d) */
    e.employee_id, e.first_name, d.department_name
FROM employees e
JOIN departments d ON e.department_id = d.department_id;

-- Force parallel processing
SELECT /*+ PARALLEL(e, 4) */
    department_id, AVG(salary), COUNT(*)
FROM employees e
GROUP BY department_id;

-- Optimize for first rows
SELECT /*+ FIRST_ROWS(10) */
    employee_id, first_name, last_name, salary
FROM employees
WHERE department_id = 10
ORDER BY salary DESC;

-- 5. SUBQUERY OPTIMIZATION
-- Bad: Correlated subquery
SELECT e1.employee_id, e1.first_name, e1.salary
FROM employees e1
WHERE e1.salary > (
    SELECT AVG(e2.salary)
    FROM employees e2
    WHERE e2.department_id = e1.department_id
);

-- Good: Use window functions
SELECT employee_id, first_name, salary
FROM (
    SELECT 
        employee_id, 
        first_name, 
        salary,
        department_id,
        AVG(salary) OVER (PARTITION BY department_id) as avg_dept_salary
    FROM employees
)
WHERE salary > avg_dept_salary;

-- 6. EXISTS vs IN optimization
-- Use EXISTS instead of IN with subqueries
SELECT d.department_name
FROM departments d
WHERE EXISTS (
    SELECT 1 FROM employees e 
    WHERE e.department_id = d.department_id
    AND e.salary > 50000
);

-- Better than:
SELECT d.department_name
FROM departments d
WHERE d.department_id IN (
    SELECT e.department_id FROM employees e 
    WHERE e.salary > 50000
);

-- 7. PAGINATION OPTIMIZATION
-- Bad: Using ROWNUM for large offsets
SELECT * FROM (
    SELECT a.*, ROWNUM rnum FROM (
        SELECT * FROM employees ORDER BY salary DESC
    ) a
    WHERE ROWNUM <= 1000
)
WHERE rnum >= 991;

-- Good: Use OFFSET/FETCH (Oracle 12c+)
SELECT employee_id, first_name, last_name, salary
FROM employees
ORDER BY salary DESC
OFFSET 990 ROWS FETCH NEXT 10 ROWS ONLY;

-- 8. ANALYTICAL FUNCTIONS vs SELF-JOINS
-- Bad: Self-join for ranking
SELECT e1.employee_id, e1.first_name, e1.salary,
       COUNT(e2.employee_id) as rank
FROM employees e1
LEFT JOIN employees e2 ON e1.department_id = e2.department_id 
                       AND e1.salary <= e2.salary
GROUP BY e1.employee_id, e1.first_name, e1.salary
ORDER BY rank;

-- Good: Use analytical functions
SELECT employee_id, first_name, salary,
       RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as rank
FROM employees
ORDER BY department_id, rank;

-- 9. BULK OPERATIONS
-- Bad: Row-by-row processing
UPDATE employees SET salary = salary * 1.1 WHERE department_id = 10;
UPDATE employees SET salary = salary * 1.05 WHERE department_id = 20;

-- Good: Single statement with CASE
UPDATE employees 
SET salary = salary * 
    CASE department_id
        WHEN 10 THEN 1.1
        WHEN 20 THEN 1.05
        ELSE 1.0
    END
WHERE department_id IN (10, 20);

-- 10. STATISTICS AND HISTOGRAMS
-- Gather table statistics for better execution plans
BEGIN
    DBMS_STATS.GATHER_TABLE_STATS(
        ownname => 'HR',
        tabname => 'EMPLOYEES',
        estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE,
        method_opt => 'FOR ALL COLUMNS SIZE AUTO',
        cascade => TRUE
    );
END;
/

-- 11. MATERIALIZED VIEWS for complex aggregations
CREATE MATERIALIZED VIEW mv_dept_summary
BUILD IMMEDIATE
REFRESH FAST ON COMMIT
AS
SELECT 
    d.department_id,
    d.department_name,
    COUNT(e.employee_id) as employee_count,
    AVG(e.salary) as avg_salary,
    SUM(e.salary) as total_salary,
    MAX(e.salary) as max_salary,
    MIN(e.salary) as min_salary
FROM departments d
LEFT JOIN employees e ON d.department_id = e.department_id
GROUP BY d.department_id, d.department_name;

-- 12. PARTITIONING for large tables
-- Range partitioning by date
CREATE TABLE sales_partitioned (
    sale_id NUMBER,
    sale_date DATE,
    customer_id NUMBER,
    amount NUMBER
)
PARTITION BY RANGE (sale_date) (
    PARTITION p_2023 VALUES LESS THAN (DATE '2024-01-01'),
    PARTITION p_2024 VALUES LESS THAN (DATE '2025-01-01'),
    PARTITION p_2025 VALUES LESS THAN (DATE '2026-01-01')
);

-- Hash partitioning for even distribution
CREATE TABLE employees_partitioned (
    employee_id NUMBER,
    first_name VARCHAR2(50),
    last_name VARCHAR2(50),
    department_id NUMBER,
    salary NUMBER
)
PARTITION BY HASH (employee_id) PARTITIONS 4;

-- 13. QUERY REWRITING TECHNIQUES
-- Use UNION ALL instead of UNION when duplicates are not an issue
SELECT employee_id, 'CURRENT' as status FROM employees WHERE status = 'ACTIVE'
UNION ALL
SELECT employee_id, 'FORMER' as status FROM former_employees;

-- Use CASE instead of multiple queries
SELECT 
    department_id,
    COUNT(CASE WHEN salary > 50000 THEN 1 END) as high_salary_count,
    COUNT(CASE WHEN salary <= 50000 THEN 1 END) as low_salary_count,
    AVG(CASE WHEN salary > 50000 THEN salary END) as avg_high_salary,
    AVG(CASE WHEN salary <= 50000 THEN salary END) as avg_low_salary
FROM employees
GROUP BY department_id;

-- 14. MONITORING AND TUNING QUERIES
-- Monitor long-running queries
SELECT 
    sql_id,
    sql_text,
    executions,
    elapsed_time/1000000 as elapsed_seconds,
    cpu_time/1000000 as cpu_seconds,
    buffer_gets,
    disk_reads,
    rows_processed
FROM v$sql
WHERE elapsed_time > 5000000  -- More than 5 seconds
ORDER BY elapsed_time DESC;

-- Find queries with high logical reads
SELECT 
    sql_id,
    sql_text,
    executions,
    buffer_gets,
    buffer_gets/executions as gets_per_exec,
    rows_processed
FROM v$sql
WHERE executions > 0
ORDER BY buffer_gets/executions DESC;

-- 15. ADVANCED OPTIMIZATION EXAMPLES
-- Optimized hierarchical query
WITH emp_hierarchy AS (
    SELECT 
        employee_id,
        manager_id,
        first_name,
        last_name,
        1 as level,
        CAST(employee_id AS VARCHAR2(4000)) as path
    FROM employees
    WHERE manager_id IS NULL
    
    UNION ALL
    
    SELECT 
        e.employee_id,
        e.manager_id,
        e.first_name,
        e.last_name,
        eh.level + 1,
        eh.path || ',' || e.employee_id
    FROM employees e
    JOIN emp_hierarchy eh ON e.manager_id = eh.employee_id
    WHERE eh.level < 10
)
SELECT /*+ MATERIALIZE */ * FROM emp_hierarchy;

-- Optimized pivot operation
SELECT 
    department_id,
    SUM(CASE WHEN job_id = 'IT_PROG' THEN salary ELSE 0 END) as it_prog_total,
    SUM(CASE WHEN job_id = 'SA_MAN' THEN salary ELSE 0 END) as sa_man_total,
    SUM(CASE WHEN job_id = 'ST_CLERK' THEN salary ELSE 0 END) as st_clerk_total,
    COUNT(CASE WHEN job_id = 'IT_PROG' THEN 1 END) as it_prog_count,
    COUNT(CASE WHEN job_id = 'SA_MAN' THEN 1 END) as sa_man_count,
    COUNT(CASE WHEN job_id = 'ST_CLERK' THEN 1 END) as st_clerk_count
FROM employees
GROUP BY department_id;

-- 16. PERFORMANCE BEST PRACTICES SUMMARY
/*
1. Always analyze execution plans before and after changes
2. Use appropriate indexes (B-tree, bitmap, function-based)
3. Avoid functions in WHERE clauses
4. Use bind variables to prevent hard parsing
5. Choose the right join algorithm (NESTED LOOPS, HASH, SORT-MERGE)
6. Use analytical functions instead of self-joins
7. Prefer EXISTS over IN for subqueries
8. Use UNION ALL instead of UNION when possible
9. Implement proper partitioning for large tables
10. Keep statistics current with DBMS_STATS
11. Use materialized views for complex aggregations
12. Consider parallel processing for large data sets
13. Use bulk operations for DML
14. Monitor and tune regularly using AWR and ASH reports
15. Use hints judiciously, not as a first resort
*/`
    },
    {
        id: 15,
        category: 'basic',
        difficulty: 'basic',
        question: 'What are Oracle constraints and how do you use them?',
        answer: 'Oracle constraints are rules that enforce data integrity. Types include NOT NULL, UNIQUE, PRIMARY KEY, FOREIGN KEY, and CHECK constraints.',
        language: 'Oracle SQL',
        code: `-- 1. NOT NULL CONSTRAINT
-- Column-level NOT NULL constraint
CREATE TABLE employees_demo (
    employee_id NUMBER NOT NULL,
    first_name VARCHAR2(50) NOT NULL,
    last_name VARCHAR2(50) NOT NULL,
    email VARCHAR2(100),
    salary NUMBER
);

-- Add NOT NULL constraint to existing column
ALTER TABLE employees_demo MODIFY email NOT NULL;

-- 2. UNIQUE CONSTRAINT
-- Column-level unique constraint
CREATE TABLE departments_demo (
    department_id NUMBER PRIMARY KEY,
    department_name VARCHAR2(100) UNIQUE,
    location_id NUMBER
);

-- Table-level unique constraint
CREATE TABLE employees_demo2 (
    employee_id NUMBER,
    first_name VARCHAR2(50),
    last_name VARCHAR2(50),
    email VARCHAR2(100),
    phone VARCHAR2(20),
    CONSTRAINT uk_emp_email UNIQUE (email),
    CONSTRAINT uk_emp_phone UNIQUE (phone)
);

-- Composite unique constraint
ALTER TABLE employees_demo2 
ADD CONSTRAINT uk_emp_name_dept UNIQUE (first_name, last_name, department_id);

-- 3. PRIMARY KEY CONSTRAINT
-- Single column primary key
CREATE TABLE customers (
    customer_id NUMBER PRIMARY KEY,
    customer_name VARCHAR2(100) NOT NULL,
    email VARCHAR2(100) UNIQUE
);

-- Composite primary key
CREATE TABLE order_items (
    order_id NUMBER,
    product_id NUMBER,
    quantity NUMBER,
    unit_price NUMBER,
    CONSTRAINT pk_order_items PRIMARY KEY (order_id, product_id)
);

-- Add primary key to existing table
ALTER TABLE employees_demo 
ADD CONSTRAINT pk_employees_demo PRIMARY KEY (employee_id);

-- 4. FOREIGN KEY CONSTRAINT
-- Basic foreign key
CREATE TABLE orders (
    order_id NUMBER PRIMARY KEY,
    customer_id NUMBER,
    order_date DATE,
    CONSTRAINT fk_orders_customer FOREIGN KEY (customer_id) 
        REFERENCES customers(customer_id)
);

-- Foreign key with cascade options
CREATE TABLE employees_fk_demo (
    employee_id NUMBER PRIMARY KEY,
    department_id NUMBER,
    manager_id NUMBER,
    first_name VARCHAR2(50),
    last_name VARCHAR2(50),
    CONSTRAINT fk_emp_dept FOREIGN KEY (department_id) 
        REFERENCES departments(department_id) ON DELETE CASCADE,
    CONSTRAINT fk_emp_manager FOREIGN KEY (manager_id) 
        REFERENCES employees_fk_demo(employee_id) ON DELETE SET NULL
);

-- 5. CHECK CONSTRAINT
-- Simple check constraint
CREATE TABLE products (
    product_id NUMBER PRIMARY KEY,
    product_name VARCHAR2(100) NOT NULL,
    price NUMBER CHECK (price > 0),
    category VARCHAR2(50) CHECK (category IN ('Electronics', 'Clothing', 'Books', 'Home')),
    stock_quantity NUMBER DEFAULT 0 CHECK (stock_quantity >= 0)
);

-- Complex check constraint
ALTER TABLE employees_demo 
ADD CONSTRAINT chk_salary_range CHECK (salary BETWEEN 1000 AND 500000);

-- Multi-column check constraint
ALTER TABLE employees_demo 
ADD hire_date DATE,
ADD CONSTRAINT chk_hire_date CHECK (hire_date <= SYSDATE);

-- 6. CONSTRAINT MANAGEMENT
-- Enable/Disable constraints
ALTER TABLE employees_demo DISABLE CONSTRAINT chk_salary_range;
ALTER TABLE employees_demo ENABLE CONSTRAINT chk_salary_range;

-- Drop constraints
ALTER TABLE employees_demo DROP CONSTRAINT chk_salary_range;

-- Rename constraints
ALTER TABLE employees_demo RENAME CONSTRAINT pk_employees_demo TO pk_emp_demo_id;

-- 7. CONSTRAINT VALIDATION
-- Add constraint with NOVALIDATE (doesn't check existing data)
ALTER TABLE employees_demo 
ADD CONSTRAINT chk_email_format CHECK (email LIKE '%@%.%') NOVALIDATE;

-- Validate constraint later
ALTER TABLE employees_demo MODIFY CONSTRAINT chk_email_format VALIDATE;

-- 8. DEFERRABLE CONSTRAINTS
-- Create deferrable constraint
CREATE TABLE parent_table (
    id NUMBER PRIMARY KEY,
    name VARCHAR2(100)
);

CREATE TABLE child_table (
    id NUMBER PRIMARY KEY,
    parent_id NUMBER,
    name VARCHAR2(100),
    CONSTRAINT fk_child_parent FOREIGN KEY (parent_id) 
        REFERENCES parent_table(id) DEFERRABLE INITIALLY DEFERRED
);

-- Use deferred constraint checking
SET CONSTRAINTS fk_child_parent DEFERRED;
-- Perform operations that might temporarily violate constraint
-- Constraints are checked at commit time

-- 9. VIEW CONSTRAINT INFORMATION
-- View all constraints for a table
SELECT 
    constraint_name,
    constraint_type,
    search_condition,
    status,
    validated,
    deferrable,
    deferred
FROM user_constraints
WHERE table_name = 'EMPLOYEES_DEMO';

-- View constraint columns
SELECT 
    c.constraint_name,
    c.constraint_type,
    cc.column_name,
    cc.position
FROM user_constraints c
JOIN user_cons_columns cc ON c.constraint_name = cc.constraint_name
WHERE c.table_name = 'EMPLOYEES_DEMO'
ORDER BY c.constraint_name, cc.position;

-- View foreign key relationships
SELECT 
    a.table_name as child_table,
    a.column_name as child_column,
    a.constraint_name,
    b.table_name as parent_table,
    b.column_name as parent_column
FROM user_cons_columns a
JOIN user_constraints c ON a.constraint_name = c.constraint_name
JOIN user_cons_columns b ON c.r_constraint_name = b.constraint_name
WHERE c.constraint_type = 'R'
ORDER BY a.table_name, a.constraint_name;

-- 10. CONSTRAINT VIOLATIONS AND ERROR HANDLING
-- Create table with various constraints for testing
CREATE TABLE employee_test (
    employee_id NUMBER CONSTRAINT pk_emp_test PRIMARY KEY,
    first_name VARCHAR2(50) NOT NULL,
    last_name VARCHAR2(50) NOT NULL,
    email VARCHAR2(100) CONSTRAINT uk_emp_test_email UNIQUE,
    department_id NUMBER CONSTRAINT fk_emp_test_dept 
        REFERENCES departments(department_id),
    salary NUMBER CONSTRAINT chk_emp_test_salary CHECK (salary > 0),
    hire_date DATE DEFAULT SYSDATE,
    status VARCHAR2(20) DEFAULT 'ACTIVE' 
        CONSTRAINT chk_emp_test_status CHECK (status IN ('ACTIVE', 'INACTIVE', 'TERMINATED'))
);

-- 11. CONSTRAINT PERFORMANCE CONSIDERATIONS
-- Use indexes to support constraints
CREATE INDEX idx_emp_test_dept ON employee_test(department_id);
CREATE INDEX idx_emp_test_email ON employee_test(email);

-- 12. CONSTRAINT BEST PRACTICES
/*
Best Practices for Oracle Constraints:

1. Always name your constraints explicitly
2. Use meaningful constraint names (pk_, fk_, uk_, chk_)
3. Create indexes on foreign key columns for performance
4. Use CHECK constraints for business rules
5. Consider using DEFERRABLE constraints for complex operations
6. Use CASCADE options carefully with foreign keys
7. Validate constraints during off-peak hours
8. Monitor constraint violations in application logs
9. Document constraint logic for complex business rules
10. Use NOVALIDATE for adding constraints to large existing tables
*/

-- Example of well-designed table with proper constraints
CREATE TABLE comprehensive_employee (
    employee_id NUMBER 
        CONSTRAINT pk_comp_emp PRIMARY KEY,
    employee_number VARCHAR2(10) 
        CONSTRAINT uk_comp_emp_number UNIQUE NOT NULL,
    first_name VARCHAR2(50) 
        CONSTRAINT nn_comp_emp_fname NOT NULL,
    last_name VARCHAR2(50) 
        CONSTRAINT nn_comp_emp_lname NOT NULL,
    email VARCHAR2(100) 
        CONSTRAINT uk_comp_emp_email UNIQUE
        CONSTRAINT nn_comp_emp_email NOT NULL
        CONSTRAINT chk_comp_emp_email CHECK (email LIKE '%@%.%'),
    phone VARCHAR2(20)
        CONSTRAINT chk_comp_emp_phone CHECK (REGEXP_LIKE(phone, '^[0-9-+ ()]+$')),
    hire_date DATE DEFAULT SYSDATE
        CONSTRAINT nn_comp_emp_hire_date NOT NULL
        CONSTRAINT chk_comp_emp_hire_date CHECK (hire_date <= SYSDATE),
    salary NUMBER
        CONSTRAINT chk_comp_emp_salary CHECK (salary BETWEEN 1000 AND 1000000),
    department_id NUMBER
        CONSTRAINT fk_comp_emp_dept REFERENCES departments(department_id),
    manager_id NUMBER
        CONSTRAINT fk_comp_emp_manager REFERENCES comprehensive_employee(employee_id),
    status VARCHAR2(20) DEFAULT 'ACTIVE'
        CONSTRAINT chk_comp_emp_status CHECK (status IN ('ACTIVE', 'INACTIVE', 'TERMINATED')),
    created_date DATE DEFAULT SYSDATE NOT NULL,
    last_modified DATE DEFAULT SYSDATE NOT NULL,
    CONSTRAINT chk_comp_emp_dates CHECK (last_modified >= created_date)
);`
    }
];


        

    
    


    

        // Load questions when page loads
        function loadQuestions() {
            const container = document.getElementById('questionsContainer');
            container.innerHTML = '';
            
            oracleSqlQuestions.forEach(question => {
                const questionElement = createQuestionElement(question);
                container.appendChild(questionElement);
            });
        }

        // Initialize questions on page load
        document.addEventListener('DOMContentLoaded', function() {
            loadQuestions();
        });
    </script>
</body>
</html>
